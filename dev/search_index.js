var documenterSearchIndex = {"docs":
[{"location":"Labels/#Adding-Labels-to-Jot-objects","page":"Labels","title":"Adding Labels to Jot objects","text":"","category":"section"},{"location":"Labels/","page":"Labels","title":"Labels","text":"Both Docker and AWS have labelling/tagging features, which allow user-defined metadata to be attached to Local docker images, AWS ECR Repos, and AWS Lambda functions. Jot leverages these features to attach Jot-generated labels to resources generated via Jot, and allows user-defined labels to be added alongside these. These labels are key/value pairs and (by a limitation of AWS) both the key and the value must be strings.","category":"page"},{"location":"Labels/","page":"Labels","title":"Labels","text":"User-defined labels can be set in the create_local_image function via the user_defined_labels keyword argument:","category":"page"},{"location":"Labels/","page":"Labels","title":"Labels","text":"create_local_image(\"my_lambda\", my_responder; user_defined_labels = Dict(\"name\" => \"my_lambda\"))","category":"page"},{"location":"Labels/","page":"Labels","title":"Labels","text":"They are then added to the underlying Docker image, and carried through to all subsequent Jot-generated resources (remote images hosted on AWS ECR, and lambda functions). The get_user_labels function can be used to recover these labels from their respective resources, eg:","category":"page"},{"location":"Labels/","page":"Labels","title":"Labels","text":"local_image = get_local_image(\"my_lambda\")\nget_user_labels(local_image)\n\nlambda_function = get_lambda_function(\"my_lambda\")\nget_user_labels(lambda_function)","category":"page"},{"location":"Types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"Types/","page":"Types","title":"Types","text":"AbstractResponder\nAWSConfig\nContainer\nLambdaFunction\nLocalImage\nLocalPackageResponder\nRemoteImage","category":"page"},{"location":"Types/#Jot.AbstractResponder","page":"Types","title":"Jot.AbstractResponder","text":"abstract type AbstractResponder{IT} end\n\nThe supertype of all responder types. The type parameter represents the parameter type of the response_function responder attribute.\n\n\n\n\n\n","category":"type"},{"location":"Types/#Jot.AWSConfig","page":"Types","title":"Jot.AWSConfig","text":"mutable struct AWSConfig\n    account_id::Union{Missing, String} = missing\n    region::Union{Missing, String} = missing\nend\n\nDefines the Amazon Web Services account id and region to use.\n\nYour current AWS CLI profile should match the account id specified here. To check that this is the case, run aws sts get-caller-identity --query Account --output text from the command line. To see available profiles, run aws configure list-profiles.\n\n\n\n\n\n","category":"type"},{"location":"Types/#Jot.Container","page":"Types","title":"Jot.Container","text":"mutable struct Container\n    ID::String\n    Image::String\n    Command::Union{Missing, String} = missing\n    CreatedAt::Union{Missing, String} = missing\n    Names::Union{Missing, String} = missing\n    Ports::Union{Missing, String} = missing\n    exists::Bool = true\nend\n\nRepresents a docker container on the local environment. Should not be instantiated directly. If  exists is true, then the container is assumed to exit and so should be visible from utilities  such as docker container ls --all.\n\n\n\n\n\n","category":"type"},{"location":"Types/#Jot.LambdaFunction","page":"Types","title":"Jot.LambdaFunction","text":"@with_kw mutable struct LambdaFunction\n    FunctionName::Union{Missing, String} = missing\n    FunctionArn::Union{Missing, String} = missing\n    Runtime::Union{Missing, String} = missing\n    Role::Union{Missing, String} = missing\n    Handler::Union{Missing, String} = missing\n    CodeSize::Union{Missing, Int64} = missing\n    Description::Union{Missing, String} = missing\n    Timeout::Union{Missing, Int64} = missing\n    MemorySize::Union{Missing, Int64} = missing\n    LastModified::Union{Missing, String} = missing\n    CodeSha256::Union{Missing, String} = missing\n    Version::Union{Missing, String} = missing\n    TracingConfig::Union{Missing, Dict{String, Any}} = missing\n    RevisionId::Union{Missing, String} = missing\n    PackageType::Union{Missing, String} = missing\n    exists::Bool = true\nend\n\nRepresents a Lambda function, hosted on AWS. Should not be instantiated directly. If exists is true, then the image is assumed to exit and so should be visible from utilities such as aws lambda list-functions\n\n\n\n\n\n","category":"type"},{"location":"Types/#Jot.LocalImage","page":"Types","title":"Jot.LocalImage","text":"mutable struct LocalImage\n    CreatedAt::Union{Missing, String} = missing\n    Digest::String\n    ID::String\n    Repository::String\n    Size::Union{Missing, String} = missing\n    Tag::String\n    exists::Bool = true\nend\n\nRepresents a docker image on the local machine, and stores associated metadata. Should not be instantiated directly. If exists is true, then the image is assumed to exit and so should be visible from utilities such as docker image ls.\n\n\n\n\n\n","category":"type"},{"location":"Types/#Jot.LocalPackageResponder","page":"Types","title":"Jot.LocalPackageResponder","text":"struct LocalPackageResponder{IT} <: AbstractResponder{IT}\n    pkg::Pkg.Types.PackageSpec\n    original_path::String\n    response_function::Symbol\n    response_function_param_type::Type{IT}\n    build_dir::String\n    package_name::String\n    registry_urls::Vector{String}\nend\n\nA responder that is located locally (in the temporary build_dir) and is a Julia package. This is usually created by the Responder function.\n\n\n\n\n\n","category":"type"},{"location":"Types/#Jot.RemoteImage","page":"Types","title":"Jot.RemoteImage","text":"@with_kw mutable struct RemoteImage\n    imageDigest::Union{Missing, String} = missing\n    imageTag::Union{Missing, String} = missing\n    ecr_repo::Union{Missing, ECRRepo} = missing\n    exists::Bool = true\nend\n\nRepresents a docker image stored in an AWS ECR Repository. The exists attribute indicates whether the RemoteImage still exists.\n\n\n\n\n\n","category":"type"},{"location":"Managing_lambdas/#Managing-Lambda-Functions-using-Jot","page":"Managing Lambdas","title":"Managing Lambda Functions using Jot","text":"","category":"section"},{"location":"Managing_lambdas/","page":"Managing Lambdas","title":"Managing Lambdas","text":"Jot.jl can be used to inventory and manage existing lambda functions. Local docker images, remote docker images (hosted on AWS ECR), and AWS-hosted Lambda functions that share identical underlying code are grouped together into LambdaComponents objects. Whether two pieces of code are identical or not is determined by finding their Git tree hash. This provides a reliable way to distinguish between, for example, two local docker images created via Jot.jl that may share the same name, Project.toml, version and git commit, but where the underlying code was tweaked between the creation of the two images. A LambdaComponents struct groups together objects that have identical function code.","category":"page"},{"location":"Managing_lambdas/","page":"Managing Lambdas","title":"Managing Lambdas","text":"The show_lambdas() function organizes local images, remote images and lambda functions into LambdaComponents and displays it: (Image: )","category":"page"},{"location":"Managing_lambdas/","page":"Managing Lambdas","title":"Managing Lambdas","text":"The Responder column is colour-coded:","category":"page"},{"location":"Managing_lambdas/","page":"Managing Lambdas","title":"Managing Lambdas","text":"Grey indicates that, if a local file-path, the path no longer exists.\nWhite indicates that the Responder path still exists.\nBlue indicates not just that the resource used to create the function still exists, but also that it contains underlying code which matches this LambdaComponents.","category":"page"},{"location":"Guide/#Guide","page":"Guide","title":"Guide","text":"","category":"section"},{"location":"Guide/#Installation","page":"Guide","title":"Installation","text":"","category":"section"},{"location":"Guide/","page":"Guide","title":"Guide","text":"From the Julia REPL, type ] to enter the Pkg REPL mode, then","category":"page"},{"location":"Guide/","page":"Guide","title":"Guide","text":"Pkg.add(url=\"https://github.com/harris-chris/Jot.jl#main\")","category":"page"},{"location":"Guide/#Background","page":"Guide","title":"Background","text":"","category":"section"},{"location":"Guide/","page":"Guide","title":"Guide","text":"Julia is not a natively supported language on AWS Lambda. However, a given Julia function can still be used on AWS Lambda by building it into a Docker container, then have that container implement AWS's Lambda API.","category":"page"},{"location":"Guide/","page":"Guide","title":"Guide","text":"Jot uses a four-step process to go from a given block of Julia code, to a working AWS Lambda function. Each step of this process is represented by a different type in Jot. These types are handles for real-life resources, whether on the local filesystem or on AWS:","category":"page"},{"location":"Guide/","page":"Guide","title":"Guide","text":"Responder -> LocalImage -> RemoteImage -> LambdaFunction","category":"page"},{"location":"Guide/","page":"Guide","title":"Guide","text":"A Responder is our chosen code for responding to Lambda Function calls. It can be as simple as a single function in a short Julia script, or it can be a fully-developed package with multiple dependencies.","category":"page"},{"location":"Guide/","page":"Guide","title":"Guide","text":"A LocalImage is a locally-hosted docker image that has Julia installed. In the process of creating a LocalImage, the code specified by the Responder will be added to it and enabled for use. A LocalImage is unique by both - in Docker terminology - its Repository (basic identity) and its Tag (version). Therefore different versions/tags of the same basic image will be represented by different LocalImages. As well as the code specified by the Responder, a given LocalImage will also have the Jot.jl package itself installed. Jot.jl hosts the Responder, handling HTTP routing and JSON conversion. Additionally, the LocalImage has AWS RIE installed, a utility provided by AWS that emulates the Lambda run-time environment and so enables local testing of the function.","category":"page"},{"location":"Guide/","page":"Guide","title":"Guide","text":"A RemoteImage represents a LocalImage, after it has been uploaded to AWS ECR. All RemoteImages must be stored in an ECR Repo. This repo maps to the image Repository. A repo may therefore contain multiple versions/tags for the same Repository; therefore multiple RemoteImages that share a Repository may be stored in the same ECR Repo.","category":"page"},{"location":"Guide/","page":"Guide","title":"Guide","text":"A LambdaFunction is the final stage in the process and represents a working Lambda function, powered by a single RemoteImage.","category":"page"},{"location":"Guide/#Best-practices","page":"Guide","title":"Best practices","text":"","category":"section"},{"location":"Guide/#Using-PackageCompiler.jl","page":"Guide","title":"Using PackageCompiler.jl","text":"","category":"section"},{"location":"Guide/","page":"Guide","title":"Guide","text":"PackageCompiler.jl is a Julia package that pre-compiles methods. This can be done during the image creation process, and the create_local_image function has a package_compile option (default false) to indicate whether this should be used. Setting package_compile to true is highly recommended for production use; it eliminates almost all of the usual delay while Julia starts up, and so reduces Lambda Function cold start-up times by around 75%, making it competitive with any other language used for AWS Lambda.","category":"page"},{"location":"Guide/","page":"Guide","title":"Guide","text":"PackageCompiler.jl works best when it is given some kind of sample use case; this tells it which methods it should be pre-compiling. By default, this use case involves calling the Responder with an empty string as the argument. However, if you are using a package as a responder, and this package has a test suite, then this will also be used as part of the use case, further improving performance. Jot.jl assumes that the test suite can be found at the standard location of <package base>/test/runtests.jl.","category":"page"},{"location":"Guide/#Working-around-the-one-function-per-container-limit","page":"Guide","title":"Working around the one-function-per-container limit","text":"","category":"section"},{"location":"Guide/","page":"Guide","title":"Guide","text":"The Lambda API limits you to one function per container. In practice, dividing up all your functions into different containers is not practical. Instead, have the responding function expect a Dict, then use one of the fields of the dict to indicate the function that should be called. The responding function can then just forward the other parameters to the appropriate function.","category":"page"},{"location":"Guide/","page":"Guide","title":"Guide","text":"So instead of creating one responder to do addition:","category":"page"},{"location":"Guide/","page":"Guide","title":"Guide","text":"function add_response_function(a::Number, b::Number) a + b end","category":"page"},{"location":"Guide/","page":"Guide","title":"Guide","text":"and another to do subtraction:","category":"page"},{"location":"Guide/","page":"Guide","title":"Guide","text":"function subtract_response_function(a::Number, b::Number) a - b end","category":"page"},{"location":"Guide/","page":"Guide","title":"Guide","text":"and having these as separate images, instead create a single responding function:","category":"page"},{"location":"Guide/","page":"Guide","title":"Guide","text":"function arithmetic_response(f::String, a::Number, b::Number)\n    if f == \"add\" a + b\n    elseif f == \"subtract\" a - b\n    else error(\"Unable to recognize desired function\")\n    end\nend","category":"page"},{"location":"Examples/#Jot-Usage-Examples","page":"Examples","title":"Jot Usage Examples","text":"","category":"section"},{"location":"Examples/#To-make-a-simple-script-into-a-Lambda-function...","page":"Examples","title":"To make a simple script into a Lambda function...","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"... where the script is located at /path/to/script.jl, and contains a function called response_func, that takes a single argument of type Dict:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"ex1_responder = get_responder(\"/path/to/script.jl\", :response_func, Dict)\nex1_local_image = create_local_image(\"ex1\", ex1_responder)\nex1_remote_image = push_to_ecr!(ex1_local_image)\nex1_lambda = create_lambda_function(ex1_remote_image)","category":"page"},{"location":"Examples/#To-make-a-script-with-dependencies-into-a-Lambda-function...","page":"Examples","title":"To make a script with dependencies into a Lambda function...","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"... where the script is located at /path/to/script.jl, and contains a function called response_func, that takes a single argument of type Dict. The script uses the SpecialFunctions.jl package:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"ex2_responder = get_responder(\"/path/to/script.jl\", :response_func, Dict; dependencies=[\"SpecialFunctions\"])\nex2_local_image = create_local_image(\"ex2\", ex2_responder)\nex2_remote_image = push_to_ecr!(ex2_local_image)\nex1_lambda = create_lambda_function(ex2_remote_image)","category":"page"},{"location":"Examples/#To-make-a-package-into-a-LocalImage,-using-PackageCompiler-to-reduce-its-cold-start-time...","page":"Examples","title":"To make a package into a LocalImage, using PackageCompiler to reduce its cold start time...","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"... where the package root (containing the Project.toml) is /path/to/project, and the package contains a function called response_func, that takes a single argument of type Vector{T} where {T <: Number}:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"ex3_responder = get_responder(\"/path/to/project\", :response_func, Vector)\nex3_local_image = create_local_image(\"ex3\", ex3_responder; package_compile=true)","category":"page"},{"location":"Examples/#To-make-a-package-on-github-into-a-responder...","page":"Examples","title":"To make a package on github into a responder...","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"... where the package url is https://github.com/harris-chris/JotTest3/blob/main/Project.toml, and the package contains a function called response_func, that takes a single argument of type Vector{T} where {T <: Number}:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"ex4_responder = get_responder(\"https://github.com/harris-chris/JotTest3/blob/main/Project.toml\", :response_func, Vector)\nex4_local_image = create_local_image(\"ex4\", ex4_responder)","category":"page"},{"location":"Examples/#To-make-a-package-in-scope-into-a-Responder...","page":"Examples","title":"To make a package in scope into a Responder...","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"... where the package contains a function called response_func, that takes a single argument of type Vector{Int64}:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using IntVectorResponder\nex5_responder = get_responder(IntVectorResponder, :response_func, Vector{Int64})","category":"page"},{"location":"Examples/#To-make-a-package-into-a-local-docker-image,-and-test-it...","page":"Examples","title":"To make a package into a local docker image, and test it...","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"... where the package root (containing the Project.toml) is /path/to/project, and the package contains a function called response_func, that takes a single argument of type String and appends \" Responded\" to the end of it:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"ex6_responder = get_responder(\"/path/to/project\", :response_func, String)\nex6_local_image = create_local_image(\"ex6\", ex6_responder)\nrun_test(ex6_local_image, \"test\", \"test Responded\")","category":"page"},{"location":"Examples/#To-see-if-a-local-docker-image-has-the-same-function-as-a-remote-image...","page":"Examples","title":"To see if a local docker image has the same function as a remote image...","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"... where localimage is a local docker image, and remoteimage is hosted on AWS ECR; the matches function checks that the underlying code of the local image and the remote image match:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"matches(local_image, remote_image)","category":"page"},{"location":"Functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"Functions/","page":"Functions","title":"Functions","text":"create_lambda_function(\n    remote_image::RemoteImage;\n    role::Union{AWSRole, Nothing} = nothing,\n    function_name::Union{Nothing, String} = nothing,\n    timeout::Int64 = 60,\n    memory_size::Int64 = 2000,\n  )\ncreate_lambda_function(\n    repo::ECRRepo;\n    role::AWSRole = nothing,\n    function_name::Union{Nothing, String} = nothing,\n    image_tag::String = \"latest\",\n    timeout::Int64 = 60,\n    memory_size::Int64 = 2000,\n  )\ncreate_local_image(\n    responder::AbstractResponder;\n    image_suffix::Union{Nothing, String} = nothing,\n    aws_config::Union{Nothing, AWSConfig} = nothing,\n    image_tag::String = \"latest\",\n    no_cache::Bool = false,\n    julia_base_version::String = \"1.8.2\",\n    julia_cpu_target::String = \"x86-64\",\n    package_compile::Bool = false,\n    user_defined_labels::AbstractDict{String, String} = OrderedDict{String, String}(),\n    dockerfile_update::Function = x -> x,\n    build_args::AbstractDict{String, String} = OrderedDict{String, String}(),\n  )::LocalImage\ndelete!(con::Container)\ndelete!(repo::ECRRepo)\ndelete!(func::LambdaFunction)\ndelete!(image::LocalImage; force::Bool=false)\nget_dockerfile(\n    responder::AbstractResponder,\n    julia_base_version::String,\n    package_compile::Bool;\n    user_defined_labels::AbstractDict{String, String} = AbstractDict{String, String}(),\n    dockerfile_update::Function = x -> x,\n  )\nget_ecr_repo(image::LocalImage)\nget_ecr_repo(repo_name::String)\ncreate_lambda_components(\n    res::AbstractResponder;\n    image_suffix::Union{Nothing, String} = nothing,\n    aws_config::Union{Nothing, AWSConfig} = nothing,\n    image_tag::String = \"latest\",\n    no_cache::Bool = false,\n    julia_base_version::String = \"1.8.2\",\n    julia_cpu_target::String = \"x86-64\",\n    package_compile::Bool = false,\n    user_defined_labels::AbstractDict{String, String} = OrderedDict{String, String}(),\n    dockerfile_update::Function = x -> x,\n  )\nget_all_aws_roles()\nget_all_containers(args::Vector{String} = Vector{String}())\nget_all_ecr_repos(jot_generated_only::Bool = true)\nget_all_lambda_functions(jot_generated_only::Bool = true)\nget_all_local_images(; args::Vector{String} = Vector{String}(), jot_generated_only::Bool = true)\nget_all_remote_images(jot_generated_only::Bool = true)\nget_lambda_function(function_name::String)\nget_lambda_function(repo::ECRRepo)\nget_local_image(repository::String)\nget_remote_image(lambda_function::LambdaFunction)\nget_remote_image(local_image::LocalImage)\nget_remote_image(identity::AbstractString)\nget_responder(\n    path_url::String,\n    response_function::Symbol,\n    response_function_param_type::Type;\n    dependencies = Vector{String}(),\n    registry_urls = Vector{String}(),\n  )\nget_responder(\n    mod::Module,\n    response_function::Symbol,\n    response_function_param_type::Type;\n    registry_urls::Vector{String} = Vector{String}(),\n  )\nget_user_labels(l::Union{LocalImage, ECRRepo, RemoteImage, LambdaFunction})\ninvoke_function(\n    request::Any,\n    lambda_function::LambdaFunction;\n    check_state::Bool,\n  )\nis_container_running(con::Container)\npush_to_ecr!(image::LocalImage)\nrun_image_locally(local_image::LocalImage; detached::Bool=true)\nrun_test(\n  image::LocalImage,\n  function_argument::Any = \"\",\n  expected_response::Any = nothing;\n  then_stop::Bool = false,\n)\nrun_test(l::LambdaComponents; function_argument::Any = \"\", expected_response::Any = nothing;)\nsend_local_request(request::Any)\nshow_lambdas()\nstop_container(con::Container)\nwith_remote_image!(l::LambdaComponents)\nwith_lambda_function!(l::LambdaComponents)","category":"page"},{"location":"Functions/#Jot.create_lambda_function-Tuple{RemoteImage}","page":"Functions","title":"Jot.create_lambda_function","text":"create_lambda_function(\n    remote_image::RemoteImage;\n    role::Union{AWSRole, Nothing} = nothing,\n    function_name::Union{Nothing, String} = nothing,\n    timeout::Int64 = 60,\n    memory_size::Int64 = 2000,\n  )::LambdaFunction\n\nCreates a function that exists on the AWS Lambda service. The function will use the given RemoteImage, and runs using the given AWS Role.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Jot.create_lambda_function-Tuple{ECRRepo}","page":"Functions","title":"Jot.create_lambda_function","text":"create_lambda_function(\n    repo::ECRRepo;\n    role::AWSRole = nothing,\n    function_name::Union{Nothing, String} = nothing,\n    image_tag::String = \"latest\",\n    timeout::Int64 = 60,\n    memory_size::Int64 = 2000,\n  )::LambdaFunction\n\nCreates a function that exists on the AWS Lambda service. The function will use the given ECR Repo, and runs using the given AWS Role. If given, the image_tag will decide which of the images in the ECR Repo is used.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Base.delete!-Tuple{Container}","page":"Functions","title":"Base.delete!","text":"delete!(con::Container)\n\nDeletes the passed container from the local docker system. The Container instance continues to  exist, but has its exists attribute set to false.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Base.delete!-Tuple{ECRRepo}","page":"Functions","title":"Base.delete!","text":"delete!(repo::ECRRepo)\n\nRemoves the passed ECRRepo instance from AWS ECR, and sets the exists attribute to false to indicate it no longer exists.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Base.delete!-Tuple{LambdaFunction}","page":"Functions","title":"Base.delete!","text":"delete!(func::LambdaFunction)\n\nDeletes a Lambda function hosted on AWS. The LambdaFunction instance continues to exist, but has its exists attribute set to false.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Base.delete!-Tuple{LocalImage}","page":"Functions","title":"Base.delete!","text":"delete!(\n  image::LocalImage;\n  force::Bool=false,\n)\n\nDeletes a locally-stored docker image. The LocalImage instance continues to exist, but has its exists attribute set to false.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Jot.get_dockerfile-Tuple{AbstractResponder, String, Bool}","page":"Functions","title":"Jot.get_dockerfile","text":"get_dockerfile(\n    responder::AbstractResponder,\n    julia_base_version::String,\n    package_compile::Bool;\n    user_defined_labels::AbstractDict{String, String} = AbstractDict{String, String}(),\n    dockerfile_update::Function = x -> x,\n  )::String\n\nReturns contents for a Dockerfile. This function is called in create_local_image in order to create a local docker image.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Jot.get_ecr_repo-Tuple{LocalImage}","page":"Functions","title":"Jot.get_ecr_repo","text":"get_ecr_repo(image::LocalImage)::Union{Nothing, ECRRepo}\n\nQueries AWS and returns an ECRRepo instance that is associated with the passed local_image. Returns nothing if one cannot be found.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Jot.get_ecr_repo-Tuple{String}","page":"Functions","title":"Jot.get_ecr_repo","text":"get_ecr_repo(repo_name::String)::Union{Nothing, ECRRepo}\n\nQueries AWS and returns an ECRRepo instance with the passed repo_name. Returns nothing if one cannot be found.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Jot.create_lambda_components-Tuple{AbstractResponder}","page":"Functions","title":"Jot.create_lambda_components","text":"create_lambda_components(\n    res::AbstractResponder;\n    image_suffix::Union{Nothing, String} = nothing,\n    aws_config::Union{Nothing, AWSConfig} = nothing,\n    image_tag::String = \"latest\",\n    no_cache::Bool = false,\n    julia_base_version::String = \"1.6.7\",\n    julia_cpu_target::String = \"x86-64\",\n    package_compile::Bool = false,\n    user_defined_labels::AbstractDict{String, String} = OrderedDict{String, String}(),\n  )::LambdaComponents\n\nCreates a LocalImage from the given responder, creates a LambdaComponents object to store the local image, and then returns the LambdaComponents object.\n\nActs as an alternative to create_local_image, but returns a LambdaComponents rather than just the local image. This can be more convenient for keeping the components of a lambda function organized - for example: create_lambda_components(responder) |> with_remote_image! |> with_lambda_function! will run through the entire process of creating a local image, pushing that image to ECR, and then creating a Lambda function.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Jot.get_all_aws_roles-Tuple{}","page":"Functions","title":"Jot.get_all_aws_roles","text":"function get_all_aws_roles()::Vector{AWSRole}\n\nGet all AWS roles from the current AWS Config.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Jot.get_all_containers","page":"Functions","title":"Jot.get_all_containers","text":"get_all_containers(args::Vector{String} = Vector{String}())::Vector{Container}\n\nReturns a list of containers currently available on the local machine.\n\nargs are additional arguments passed to the docker ps call that this function wraps.\n\n\n\n\n\n","category":"function"},{"location":"Functions/#Jot.get_all_ecr_repos","page":"Functions","title":"Jot.get_all_ecr_repos","text":"get_all_ecr_repos(jot_generated_only::Bool = true)::Vector{ECRRepo}\n\nReturns a vector of ECRRepos, representing all AWS-hosted ECR Repositories.\n\njot_generated_only specifies whether to filter for jot-generated repos only.\n\n\n\n\n\n","category":"function"},{"location":"Functions/#Jot.get_all_lambda_functions","page":"Functions","title":"Jot.get_all_lambda_functions","text":"get_all_lambda_functions(jot_generated_only::Bool = true)::Vector{LambdaFunction}\n\nReturns a vector of LambdaFunctions, representing all AWS-hosted Lambda functions.\n\njot_generated_only specifies whether to filter for jot-generated lambda functions only.\n\n\n\n\n\n","category":"function"},{"location":"Functions/#Jot.get_all_local_images-Tuple{}","page":"Functions","title":"Jot.get_all_local_images","text":"get_all_local_images(;\n    args::Vector{String} = Vector{String}(),\n    jot_generated_only::Bool = true,\n  )::Vector{LocalImage}\n\nReturns a vector of LocalImages, representing all locally-stored docker images.\n\nargs are passed to the call to docker image ls, that is used to populate this vector. jot_generated_only specifies whether to filter for jot-generated images only.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Jot.get_all_remote_images","page":"Functions","title":"Jot.get_all_remote_images","text":"function get_all_remote_images(jot_generated_only::Bool = true)::Vector{RemoteImage}\n\nReturns all remote images stored on AWS ECR. By default, filters for jot-generated images only.\n\n\n\n\n\n","category":"function"},{"location":"Functions/#Jot.get_lambda_function-Tuple{String}","page":"Functions","title":"Jot.get_lambda_function","text":"get_lambda_function(function_name::String)::Union{Nothing, LambdaFunction}\n\nQueries AWS and returns a LambdaFunction object, representing a Lambda Function hosted on AWS.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Jot.get_lambda_function-Tuple{ECRRepo}","page":"Functions","title":"Jot.get_lambda_function","text":"get_lambda_function(repo::ECRRepo)::Union{Nothing, LambdaFunction}\n\nQueries AWS and returns a LambdaFunction object, representing a Lambda Function hosted on AWS. The Lambda function returned is based off the given ECRRepo instance.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Jot.get_local_image-Tuple{String}","page":"Functions","title":"Jot.get_local_image","text":"get_local_image(\n  identity::String,\n)::Union{Nothing, LocalImage}\n\nReturns a LocalImage object, representing a locally-stored docker image.\n\nThe passed identity string may be the repository name, or the docker image ID. If the image ID, it must be at least four characters in length.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Jot.get_remote_image-Tuple{LambdaFunction}","page":"Functions","title":"Jot.get_remote_image","text":"get_remote_image(lambda_function::LambdaFunction)::RemoteImage\n\nQueries AWS and returns a RemoteImage object, representing a docker image hosted on AWS ECR. The RemoteImage returned provides the code for the provided lambda_function.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Jot.get_remote_image-Tuple{LocalImage}","page":"Functions","title":"Jot.get_remote_image","text":"get_remote_image(local_image::LocalImage)::Union{Nothing, RemoteImage}\n\nQueries AWS and returns a RemoteImage instance corresponding to the given local_image.\n\nIf multiple valid images exist, this will return the first only. If none exists, returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Jot.get_remote_image-Tuple{AbstractString}","page":"Functions","title":"Jot.get_remote_image","text":"get_remote_image(identity::AbstractString)::Union{Nothing, RemoteImage}\n\nQueries AWS and returns a RemoteImage instance corresponding to the given identity string.\n\nThe identity string will attempt to match on the name of the remote image, or the image's Digest.\n\nIf multiple valid images exist, this will return the first only. If none exists, returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Jot.get_responder-Tuple{String, Symbol, Type}","page":"Functions","title":"Jot.get_responder","text":"function get_responder(\n    path_url::String,\n    response_function::Symbol,\n    response_function_param_type::Type{IT};\n    dependencies = Vector{String}(),\n    registry_urls = Vector{String}(),\n  )::AbstractResponder{IT} where {IT}\n\nReturns an AbstractResponder, a type that holds the function that will be used to respond to AWS Lambda calls.\n\npath_url may be either a local filesystem path, or a url.\n\nIf a filesystem path, it may point to either a script or a package. If a script, dependencies may be passed to specify any dependencies used in the script. If a package, the dependencies will be found automatically from its Project.toml.\n\nIf a url, it should be a remote package, for example the URL for a github repo. The url given will be passed to Pkg as a url, so any url valid in a PackageSpec will also be valid here, such as https://github.com/harris-chris/JotTest3\n\nresponse_function is a function within this module that you would like to use to respond to AWS Lambda calls. response_function_param_type specifies the type that the response function is expecting as its only argument.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Jot.get_responder-Tuple{Module, Symbol, Type}","page":"Functions","title":"Jot.get_responder","text":"function get_responder(\n    mod::Module,\n    response_function::Symbol,\n    response_function_param_type::Type{IT},\n    registry_urls::Vector{String} = Vector{String}(),\n  )::AbstractResponder{IT} where {IT}\n\nReturns an AbstractResponder, a type that holds the function that will be used to respond to AWS Lambda calls.\n\nmod is a module currently in scope, and response_function is a function within this module that you would like to use to respond to AWS Lambda calls.\n\nresponse_function is a function within this module that you would like to use to respond to AWS Lambda calls. response_function_param_type specifies the type that the response function is expecting as its only argument.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Jot.get_user_labels-Tuple{Union{ECRRepo, LambdaFunction, LocalImage, RemoteImage}}","page":"Functions","title":"Jot.get_user_labels","text":"get_user_labels(l::Union{LocalImage, ECRRepo, RemoteImage, LambdaFunction})::Dict\n\nRetrieves any user_defined labels for the given resource as a Dict of key=>value pairs.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Jot.invoke_function-Tuple{Any, LambdaFunction}","page":"Functions","title":"Jot.invoke_function","text":"invoke_function(\n    request::Any,\n    lambda_function::LambdaFunction;\n    check_state::Bool=false,\n  )::Any\n\nInvokes a Lambda function, hosted on AWS. request is the argument that it will be called with. This will be automatically converted to JSON before sending, so should match the response_function_param_type of the responder used to create the function.\n\nReturns the invoked Lambda function response, or throws an error if the invoked Lambda function has returned an error status.\n\nIf check_state is true, the function will wait for the AWS Lambda function to become available before sending the request. This can be useful if the Lambda function has been created within the last few seconds, since there is a short set-up time before it can be called.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Jot.is_container_running-Tuple{Container}","page":"Functions","title":"Jot.is_container_running","text":"is_container_running(con::Container)::Bool\n\nReturns true if the given docker container is currently running (not stopped).\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Jot.push_to_ecr!-Tuple{LocalImage}","page":"Functions","title":"Jot.push_to_ecr!","text":"push_to_ecr!(image::LocalImage)::RemoteImage\n\nPushes the given local docker image to an AWS ECR Repo, a prerequisite of creating an AWS Lambda Function. If an ECR Repo for the given local image does not exist, it will be created automatically. Returns a RemoteImage object that represents the docker image that is hosted on the ECR Repo. The ECR Repo itself is an attribute of the RemoteImage.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Jot.run_image_locally-Tuple{LocalImage}","page":"Functions","title":"Jot.run_image_locally","text":"run_image_locally(local_image::LocalImage; detached::Bool=true)::Container\n\nRuns the given local image, starting a docker container. If detached, the container will run in the background. The container can be stopped/deleted by eg stop_container, delete!.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Jot.run_test","page":"Functions","title":"Jot.run_test","text":"run_test(\n  image::LocalImage,\n  function_argument::Any = \"\",\n  expected_response::Any = nothing;\n  then_stop::Bool = false,\n)::Tuple{Bool, Float64}\n\nRuns a test of the given local docker image, passing function_argument (if given), and expecting expected_response(if given). If a function_argument is not given, then it will merely test that any kind of response is received - this response may be an error JSON and the test will still pass, establishing only that the image can be contacted. Returns a tuple of (test result, time) where time is the time taken for a response to be received, in seconds.\n\nThe test will use an already-running docker container, if one exists. If this is the case then the then_stop parameter tells the function whether to stop the docker container after running the test. If the run_test function finds no docker container already running, it will start one, and then shut it down afterwards. This is true regardless of the value of then_stop.\n\n\n\n\n\n","category":"function"},{"location":"Functions/#Jot.run_test-Tuple{LambdaComponents}","page":"Functions","title":"Jot.run_test","text":"run_test(\n    l::LambdaComponents;\n    function_argument::Any = \"\",\n    expected_response::Any = nothing;\n  )::Tuple{Bool, Float64}\n\nTests the passed LambdaComponents instance.\n\nThe test runs on the most downstream object. So if the instance has a LambdaFunction, this will be tested. Otherwise, the attached LocalImage will be tested. If the LambdaComponents object has neither a local image or a lambda function, then it has nothing that can be tested and the function will throw an error.\n\nReturns a tuple of {Test pass/fail, Test time taken in seconds}.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Jot.send_local_request-Tuple{Any}","page":"Functions","title":"Jot.send_local_request","text":"send_local_request(request::Any)\n\nMake a function call to a locally-running docker container and returns the value. A container can be initiated by eg run_image_locally.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Jot.show_lambdas-Tuple{}","page":"Functions","title":"Jot.show_lambdas","text":"show_lambdas()::Nothing\n\nDisplays a table of all objects generated using Jot.jl.\n\nEach row of the table shows at least one of a Responder, a local docker image, a remote (hosted on AWS ECR) docker image, and an AWS-hosted Lambda function. The local docker image, remote docker image and lambda function on a given row of the table are guaranteed to share the same underlying function code.\n\nThe Responder column is colour-coded:\n\nGrey indicates that this path no longer exists.\nWhite indicates that this path still exists, but the code has changed since the objects shown\n\nin the row were created.\n\nBlue indicates that the underlying code for this row (eg the code present in the local image,\n\nremote image etc) is the same as is currently present at this path.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Jot.stop_container-Tuple{Container}","page":"Functions","title":"Jot.stop_container","text":"stop_container(con::Container)\n\nStops the given docker container, if currently running.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Jot.with_remote_image!-Tuple{LambdaComponents}","page":"Functions","title":"Jot.with_remote_image!","text":"with_remote_image!(l::LambdaComponents)::LambdaComponents\n\nAdds a 'RemoteImageobject to the passedLambdaComponents` instance. Will error if the instance has neither an existing remote image or local image.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Jot.with_lambda_function!-Tuple{LambdaComponents}","page":"Functions","title":"Jot.with_lambda_function!","text":"with_lambda_function!(l::LambdaComponents)::LambdaComponents\n\nAdds a 'LambdaFunctioninstance to the passedLambdaComponents` instance. Will error if the instance has neither an existing remote image, local image or lambda function.\n\n\n\n\n\n","category":"method"},{"location":"Troubleshooting/#Troubleshooting","page":"Troubleshooting","title":"Troubleshooting","text":"","category":"section"},{"location":"Troubleshooting/#Getting-IOError(Base.IOError(\"read:-connection-reset-by-peer-(ECONNRESET)\",-104)-during-request(http://localhost:9000/2015-03-31/functions/function/invocations))-when-testing-a-local-image","page":"Troubleshooting","title":"Getting IOError(Base.IOError(\"read: connection reset by peer (ECONNRESET)\", -104) during request(http://localhost:9000/2015-03-31/functions/function/invocations)) when testing a local image","text":"","category":"section"},{"location":"Troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"This is a problem with the containerd runtime, used by the Docker daemon. Restarting the service should fix this (it may refuse to shut down when being restarted, in which case it will eventually time out). With systemd this can be done with systemctl restart containerd. Restarting the local machine will also work.","category":"page"},{"location":"#Jot.jl","page":"Home","title":"Jot.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Streamlines the creation and management of AWS Lambda functions written in Julia","category":"page"},{"location":"","page":"Home","title":"Home","text":"Amazon Web Services does not provide native support for Julia, so functions must be put into docker containers which implement AWS's Lambda API, and uploaded to AWS Elastic Container Registry (ECR). Jot aims to abstract these complexities away, allowing both julia packages and scripts to be turned into low-latency Lambda functions.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"1. From the JULIA REPL, create a simple script to use as a lambda function... ","category":"page"},{"location":"","page":"Home","title":"Home","text":"open(\"increment_vector.jl\", \"w\") do f\n  write(f, \"increment_vector(v::Vector{Int}) = map(x -> x + 1, v)\")\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"2. ...and turn it into a Responder","category":"page"},{"location":"","page":"Home","title":"Home","text":"increment_responder = get_responder(\"./increment_vector.jl\", :increment_vector, Vector{Int})","category":"page"},{"location":"","page":"Home","title":"Home","text":"3. Create a local docker image that will implement the responder","category":"page"},{"location":"","page":"Home","title":"Home","text":"local_image = create_local_image(increment_responder; image_suffix=\"increment-vector\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"4. Push this local docker image to AWS ECR","category":"page"},{"location":"","page":"Home","title":"Home","text":"remote_image = push_to_ecr!(local_image)","category":"page"},{"location":"","page":"Home","title":"Home","text":"5. Create a lambda function from this remote_image... ","category":"page"},{"location":"","page":"Home","title":"Home","text":"increment_vector_lambda = create_lambda_function(remote_image)","category":"page"},{"location":"","page":"Home","title":"Home","text":"6. ... and test it to see if it's working OK","category":"page"},{"location":"","page":"Home","title":"Home","text":"@test run_test(increment_vector_lambda, [2,3,4], [3,4,5]; check_function_state=true) |> first","category":"page"},{"location":"","page":"Home","title":"Home","text":"Alternatively, there is the LambdaComponents type, which collects together local docker images, remote docker images and lambda functions that share the same underlying function code:","category":"page"},{"location":"","page":"Home","title":"Home","text":"lambda_components = create_lambda_components(increment_responder; image_suffix=\"increment-vector\")\nlambda_components |> with_remote_image! |> with_lambda_function! |> run_test","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Easily create AWS Lambda functions from Julia packages or scripts\nTest and check for at multiple stages\nAllows easy checking for version consistency - eg, is a given Lambda Function using the correct code?\nPackageCompiler.jl may be optionally used to greatly speed up cold start times\nJSON read/write and error handling is handled by Jot - you just write standard Julia ","category":"page"}]
}
